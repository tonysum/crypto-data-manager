# 实施方案 1：实现“稳健串行”调度系统

既然您选择了方案 1，我们将通过“排队机制”和“强制限速”来彻底解决 IP 封禁问题。这能确保您的数据补全既稳健又安全。

## 1. 生活中的类比：单行道与限速牌

*   **排队机制 (Queue)**：就像把原来的多车道高速改成了**单行道**。无论触发了多少个任务（5m, 1h...），它们都必须在排队区等候，一个干完了另一个才准进去。
*   **限速牌 (Delay)**：我们把每个请求之间的休息时间拉长，让币安觉得我们是一个**“慢条斯理、不急不躁”**的正常用户。

## 2. 优化后的逻辑流程图 (ASCII)

```text
[ 调度器主循环 ] (每分钟看一次表)
       |
       |-- 发现 5m, 1h 到了 --> [ 把它们扔进排队区 ]
       |
       V
[ 任务排队区 (Queue) ] <--- 永远只有一个任务在执行
       |
       |-- 1. 执行 5m 同步 (限速 1.0s) --完成后--> |
       |-- 2. 执行 1h 同步 (限速 1.0s) --完成后--> |
       |
       V
[ 日志输出统计 ]
```

## 3. 技术改进细节

### 第一步：引入异步队列 (asyncio.Queue)
我会修改 `scheduler_klines.py`，创建一个全局队列。调度器负责“塞任务”，而一个专门的 Worker 负责“领任务并执行”。这样能物理上杜绝多个任务并发。

### 第二步：极限限速 (Throttle)
*   **`request_delay`**: 设置为 `1.0s`。
*   **`batch_delay`**: 设置为 `10.0s`。
*   **效果**：处理完全部 250 个币种大约需要 5-8 分钟。虽然慢，但它能**稳定运行几个月不出错**。

### 第三步：增强容错与静默
如果程序检测到正在被封禁，它会打印一个醒目的警告并**自动休眠 10 分钟**，而不是疯狂重试。

## 4. 关键的“坑” (Gotcha)

**“任务积压”风险**：
如果 5m 任务执行太慢（比如超过 5 分钟），队列里会堆积多个 5m 任务。
**解决方案**：我在代码中会加入**“去重检查”**。如果队列里已经有一个 5m 任务在排队或正在跑，新的 5m 任务将直接被丢弃，确保系统不会过载。

---
**如果您确认，我将立即为您重构 `backend/scheduler_klines.py` 并重启测试。**
